<?php
/**
 * @file
 * Code for the GSB Feature Working Paper Content Type feature.
 */

include_once 'gsb_feature_working_paper_ct.features.inc';

/**
 * Implements hook_menu().
 */
function gsb_feature_working_paper_ct_menu() {
  $items = array();  
  $items['admin/config/gsb/working-paper-refresh-db-email/settings'] = array(
    'title' => 'Working Paper Refresh DB Email Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('gsb_feature_working_paper_ct_refresh_db_email_settings_form'),
    'access arguments' => array('administer working paper refresh db email'),
    'file' => 'gsb_feature_working_paper_ct.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function gsb_feature_working_paper_ct_permission() {
  return array(
    'administer working paper refresh db email' => array(
      'title' => t('Administer Working Paper Refresh DB Email Settings'),
    ),
    'administer working paper metadata' => array(
      'title' => t('Administer Working Paper Metadata'),
    ),
  );
}

/**
 * Implements hook_token_info().
 */
function gsb_feature_working_paper_ct_token_info() {
  $types['refresh_databases'] = array(
    'name' => t("Refresh Databases Tokens"),
    'description' => t("Tokens from the refresh database email."),
  );  
  $tokens = array();
  $tokens['deletes'] = array(
    'name' => t('Refresh Databases that have been deleted'),
    'description' => t('Get the names of the deleted refresh databases, if any.'),
  );
  $tokens['adds'] = array(
    'name' => t('Refresh Databases that have been added'),
    'description' => t('Get the names of the added refresh databases, if any.'),
  );  
  $tokens['file_url'] = array(
    'name' => t('File url associated with the working paper'),
    'description' => t('Get the file url associated with the working paper.'),
  );
  return array(
    'types' => $types,
    'tokens' => array(
      'refresh_databases' => $tokens,
    ),
  );  
}

/**
 * Implements hook_tokens().
 */
function gsb_feature_working_paper_ct_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'refresh_databases') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'deletes':
          $deletes = $data['refresh_databases']['deletes'];
          if (empty($deletes)) {
            $deletes = '(no changes)';
          }
          $replacements[$original] = $deletes; 
          break;
        case 'adds':
          $adds = $data['refresh_databases']['adds'];
          if (empty($adds)) {
            $adds = '(no changes)';
          }
          $replacements[$original] = $adds;
          break;
        case 'file_url':
          $file_url = '';
          if (!empty($data['refresh_databases']['file_url'])) {
            $file_url = $data['refresh_databases']['file_url'];
          }
          $replacements[$original] = $file_url;
          break;
      }
    }
  }
  return $replacements;
}

/**
 * Implements hook_node_insert().
 */
function gsb_feature_working_paper_ct_node_insert($node) {
  if ($node->type == 'working_paper') {
    _gsb_feature_working_paper_ct_sendResearchDatabasesEmail($node);
  }
}

/**
 * Implements hook_node_update().
 */
function gsb_feature_working_paper_ct_node_update($node) {
  if ($node->type == 'working_paper') {
    _gsb_feature_working_paper_ct_sendResearchDatabasesEmail($node);
  }
}

/**
 * Send Research Databases email notification
 */
function _gsb_feature_working_paper_ct_sendResearchDatabasesEmail($node) {

  global $base_root, $base_path;
  global $user;

  $language = $node->language;

  // get current list of research databases from the original node
  $currrent_research_dbs = array();
  if (!empty($node->original)) {
    $currrent_research_dbs = _gsb_feature_working_paper_ct_getResearchDatabases($node->original);
  }

  // get new list of research databases from insert/update node
  $new_research_dbs = _gsb_feature_working_paper_ct_getResearchDatabases($node);

  // get list of research databases deleted and added
  list($deletes, $adds) = _gsb_feature_working_paper_ct_key_deletes_adds($currrent_research_dbs, $new_research_dbs);

  // get term names for deleted and added research databases
  $delete_names = _gsb_feature_working_paper_ct_getTermNames($deletes);
  $add_names = _gsb_feature_working_paper_ct_getTermNames($adds);

  // if there haven't been any changes in the refresh database settings, 
  // then no need to send an email
  if (empty($delete_names) && empty($add_names)) {
    return;
  }  

  // get the setting for contact mail
  $contact_email = variable_get('gsb_feature_working_paper_ct_refresh_db_contact_email', t(''));

  // get the setting for email body - which will contain tokens
  $email_body = variable_get('gsb_feature_working_paper_ct_refresh_db_email_body', t(''));

  // get the file url
  $file_url = $base_root.$base_path.'/gsb-cmis/gsb-cmis-download-doc/'.$node->nid;

  // replace the tokens in the email body
  $email_body = token_replace(
    $email_body,
    array(
      'node' => $node,
      'refresh_databases' => array(
        'deletes' => implode(",", $delete_names),
        'adds' => implode(",", $add_names),
        'file_url' => $file_url,
      )
    )
  );

  // email the notice of delete and adds to contact email address

  $params = array(
    'body' => array($email_body),
    'subject' => 'Working Paper Updated',
  );

  $email_from = 'admin@stanford.edu';
  $message = drupal_mail(
    'gsb_feature_working_paper_ct',
    'update_working_paper',
    $contact_email,
    $language,
    $params,
    $email_from,
    TRUE
  );

}

/**
 * Implements hook_mail().
 */
function gsb_feature_working_paper_ct_mail($key, &$message, $params) {
  $headers = array(
    'MIME-Version' => '1.0',
    'Content-Type' => 'text/html; charset=UTF-8;',
    'Content-Transfer-Encoding' => '8Bit',
    'X-Mailer' => 'Drupal'
  );
  foreach ($headers as $key => $value) {
    $message['headers'][$key] = $value;
  }
  $message['subject'] = $params['subject'];
  $message['body'] = $params['body'];
}

/**
 * Returns a list of term names for a given list of tids
 */
function _gsb_feature_working_paper_ct_getTermNames($tids) {
  $names = array();
  foreach ($tids as $key) {
    $taxonomy = taxonomy_term_load($key);
    $names[] = $taxonomy->name;
  }
  return $names;
}

/**
 * Finds the deletes and adds between old and new arrays
 */
function _gsb_feature_working_paper_ct_key_deletes_adds($old, $new) {
  $intersect = array_intersect_key($old,$new);
  foreach ($intersect as $key) {
    unset($old[$key]);
  }
  $deletes = $old;
  foreach ($intersect as $key) {
    unset($new[$key]);
  }
  $adds = $new;
  return array($deletes, $adds);
}

/**
 * Gets the list of Research Databases set on the node.
 */
function _gsb_feature_working_paper_ct_getResearchDatabases($node) {
  $language = $node->language;
  $research_db_list = array();
  if (isset($node->field_research_databases[$language])) {
    foreach ($node->field_research_databases[$language] as $key => $value) {
      $tid = $node->field_research_databases[$language][$key]['tid'];
      $research_db_list[$tid] = $tid;
    }
  }
  return $research_db_list;
}

/**
 * Implements hook_form_FORM_ID_alter() for working paper node edit form.
 */
function gsb_feature_working_paper_ct_form_working_paper_node_form_alter(&$form, &$form_state) {

  global $user;

  $language = $form['language']['#value'];

  // Hide the 'Alfresco Metadata' group, for any user
  // that has the 'Faculty' role
  if (in_array('Faculty', array_values($user->roles))) {
    $groups = array(
      'group_alfresco_metadata',
    );
    gsb_feature_base_fields_hide_fieldgroups($form, $groups);
  } 

  if (!user_access('administer working paper metadata')) {
    $form['field_document_uuid']['#disabled'] = TRUE;
    $form['field_link_document']['#disabled'] = TRUE;
    $form['field_document_name']['#disabled'] = TRUE;
    $form['field_item_id']['#disabled'] = TRUE;
  }

  $form['field_publication_type'][$language]['#default_value'] = 'working_paper';
  $form['field_publication_type']['#access'] = FALSE;

  $form['field_paper_copy']['#access'] = FALSE;
  $form['field_product_type']['#access'] = FALSE;

  // Add markup for the docname if we have a doc on Alfresco
  _gsb_feature_working_paper_ct_addDocName($form);

  // Research databases taxonomy field checkbox alter
  if (empty($form['nid']['#value'])) {
    $research_field = $form['field_research_databases'][$language]['#options'];
    $default_value = array();
    foreach ($research_field as $key => $value) {
      $taxonomy_term = taxonomy_term_load($key);
      if (!empty($taxonomy_term->field_default_checkbox_status[$language][0]['value'])) {
        $default_value[] = $key;
      }
    }
    $form['field_research_databases'][$language]['#default_value'] = $default_value;
  }

  $form['#validate'][] = 'gsb_feature_working_paper_ct_form_validate';

}  

/**
 * Validates the working paper node edit form.
 */
function gsb_feature_working_paper_ct_form_validate($form, &$form_state) {
}

/**
 * Sets up a callback function for handling the cmis import
 */
function gsb_feature_working_paper_ct_gsb_cmis_content_type_import_info() {
  return array(
    'working_paper' => array(
      'callback' => 'gsb_feature_working_paper_ct_cmis_import',
    ),
  );
}

/**
 * The callback function for handling the cmis import for
 * the Working Paper content type.
 */
function gsb_feature_working_paper_ct_cmis_import($doc, $uuid) {

  global $user;

  // Check if the Product Type has been set. If not, bail.
  if (empty($doc->properties['gsb:cwoProductType']) || trim($doc->properties['gsb:cwoProductType']) == '') {
    return;
  }

  // Valid Product Types for 'Working Paper' Content type is:
  //   Working Paper
  $product_type = $doc->properties['gsb:cwoProductType'];
  if ($product_type != 'Working Paper') {
    return;
  }

  // Attempt to find a node with the document uuid
  $query = new EntityFieldQuery();
  $query->fieldCondition('field_document_uuid', 'value', $uuid, '=')->range(0, 1);
  $entities = $query->execute();

  if (!empty($entities['node'])) {
    // a node already exists, so load it
    $nids = array_keys($entities['node']);
    $node = node_load(array_shift($nids));
  } else {
    // a node does exist, so create one
    $values = array(
      'type' => 'working_paper',
      'uid' => $user->uid,
      'status' => 1,
      'comment' => 1,
      'promote' => 0,
    );
    $node = entity_create('node', $values);
  }

  // if the node isn't a Working Paper, then bail
  if ($node->type != 'working_paper') {
    return;
  }

  $node->importing = true;

  if (!empty($node->nid)) {
    gsb_cmis_log('node id = '.$node->nid, 'success');
  } else {
    gsb_cmis_log('creating new node', 'success');
  }
  gsb_cmis_log('uuid = '.$uuid, 'success');

  $ewrapper = entity_metadata_wrapper('node', $node);

  gsb_cmis_log('writing document uuid', 'success');

  $ewrapper->field_document_uuid->set($uuid);

  gsb_cmis_log('writing title', 'success');

  if (!empty($doc->properties['cm:title']) && trim($doc->properties['cm:title']) != '') {
    $ewrapper->title->set($doc->properties['cm:title']);
  } else {
    // if title is empty, then try to use document name
    if (!empty($doc->properties['cmis:contentStreamFileName']) && trim($doc->properties['cmis:contentStreamFileName']) != '') {
      $ewrapper->title->set($doc->properties['cmis:contentStreamFileName']);
    } else {
      $ewrapper->title->set('no title');
    }  
  }

  gsb_cmis_log('writing field_document_name', 'success');

  if (!empty($doc->properties['cmis:contentStreamFileName']) && trim($doc->properties['cmis:contentStreamFileName']) != '') {
    gsb_cmis_log('writing field_document_name = '.$doc->properties['cmis:contentStreamFileName'], 'success');
    $ewrapper->field_document_name->set($doc->properties['cmis:contentStreamFileName']);
  } else {
    $ewrapper->field_document_name->set(NULL);
  }  

  gsb_cmis_log('writing field_description', 'success');

  if (!empty($doc->properties['cm:description']) && trim($doc->properties['cm:description']) != '') {
    $ewrapper->field_description = array(
      'value' => $doc->properties['cm:description'],
      'format' => 'gsb_wysiwyg_text',
    );    
  } else {
    $ewrapper->field_description = array(
      'value' => '',
      'format' => 'gsb_wysiwyg_text',
    );  
  }
  
  gsb_cmis_log('writing field_product_type', 'success');

  $ewrapper->field_product_type->set($product_type);

  gsb_cmis_log('writing field_business_insight_topic', 'success');

  if (!empty($doc->properties['gsb:cwoBusinessTopics']) && trim($doc->properties['gsb:cwoBusinessTopics']) != '') {
    $ids = array();
    $bi_topic = $doc->properties['gsb:cwoBusinessTopics'];
    $results = taxonomy_get_term_by_name($bi_topic);
    foreach ($results as $item) {
      if ($item->vocabulary_machine_name == 'business_insight_topic') {
        $ids[] = $item->tid;
      }
    }
    $ewrapper->field_business_insight_topic->set($ids);
  } else {
    $ewrapper->field_business_insight_topic = array();
  }

  gsb_cmis_log('writing field_academic_area_unlimited', 'success');

  if (!empty($doc->properties['gsb:cwoAcademicArea']) && trim($doc->properties['gsb:cwoAcademicArea']) != '') {
    $ids = array();
    $academic_area = $doc->properties['gsb:cwoAcademicArea'];
    $results = taxonomy_get_term_by_name($academic_area);
    foreach ($results as $item) {
      if ($item->vocabulary_machine_name == 'academic_area') {
        $ids[] = $item->tid;
      }
    }
    $ewrapper->field_academic_area_unlimited->set($ids);
  } else {
    $ewrapper->field_academic_area_unlimited = array();
  }

  gsb_cmis_log('writing field_paper_copy', 'success');

  if (!empty($doc->properties['gsb:cwoPaperCopy']) && trim($doc->properties['gsb:cwoPaperCopy']) != '') {
    $ewrapper->field_paper_copy->set($doc->properties['gsb:cwoPaperCopy']);
  } else {
    $ewrapper->field_paper_copy->set(NULL);
  }  
  
  gsb_cmis_log('writing field_item_id', 'success');

  if (!empty($doc->properties['gsb:cwoItemId']) && trim($doc->properties['gsb:cwoItemId']) != '') {
    $ewrapper->field_item_id->set($doc->properties['gsb:cwoItemId']);
  } else {
    $ewrapper->field_item_id->set(NULL);
  }  
  
  gsb_cmis_log('writing field_year_of_publication', 'success');

  if (!empty($doc->properties['gsb:cwoPublicationYear']) && trim($doc->properties['gsb:cwoPublicationYear']) != '') {
    $year = $doc->properties['gsb:cwoPublicationYear'];
    gsb_cmis_log('year = '.$year, 'success');
    if (is_numeric($year)) {
      $date = new DateTime($year."-01-01");
      $ewrapper->field_year_of_publication->set($date->getTimestamp());
      $ewrapper->field_month->set(NULL);
    } else {
      $ewrapper->field_year_of_publication = NULL;
    }
  } else {
    $ewrapper->field_year_of_publication = NULL;
  }  
  
  gsb_cmis_log('writing field_tag', 'success');

  $tags = _gsb_feature_working_paper_ct_getTags($uuid);

  if (!empty($tags)) {
    $ids = array();
    $term_list = array();
    _gsb_feature_working_paper_ct_add_tags($tags);
    foreach($tags as $term) {
      $results = taxonomy_get_term_by_name($term);
      $term_list = array_merge($term_list, $results);
    }
    foreach ($term_list as $item) {
      if ($item->vocabulary_machine_name == 'tag') {
        $ids[] = $item->tid;
      }
    }
    $ewrapper->field_tag->set($ids);
  } else {
    $ewrapper->field_tag = array();
  }

  gsb_cmis_log('writing field_has_pdf', 'success');

  if (!empty($doc->properties['cmis:contentStreamFileName']) && trim($doc->properties['cmis:contentStreamFileName']) != '') {
    $ewrapper->field_has_pdf->set("1");
  } else {
    $ewrapper->field_has_pdf->set("0");
  }

  gsb_cmis_log('writing sunet field_authors', 'success');

  if (!empty($doc->properties['gsb:authorsSunetId']) && trim($doc->properties['gsb:authorsSunetId']) != '') {
    _gsb_feature_working_paper_ct_import_sunet_authors($node,$ewrapper,$doc);
  }

  gsb_cmis_log('writing other field_authors', 'success');

  if (!empty($doc->properties['cm:author']) && trim($doc->properties['cm:author']) != '') {
    _gsb_feature_working_paper_ct_import_other_authors($node,$doc);
  }  

  gsb_cmis_log('saving node', 'success');

  $node->status = 1;
  $node->workbench_moderation['updating_live_revision'] = 1;

  $ewrapper->save();

  $node->importing = false;

}

/**
 * Add the working papers tags from the returned Alfresco data 
 */
function _gsb_feature_working_paper_ct_add_tags($tags) {
  $vocab = taxonomy_vocabulary_machine_name_load('tag');
  $vid = $vocab->vid;
  foreach($tags as $term) {
    $results = taxonomy_get_term_by_name($term);
    if (empty($results)) {
      _gsb_feature_working_paper_ct_add_tag_term($term, $vid);
    } else {
      $found = FALSE; 
      foreach ($results as $item) {
        if ($item->vocabulary_machine_name == 'tag') {
          $found = TRUE;
          break;
        }    
      }
      if (!$found) {
        _gsb_feature_working_paper_ct_add_tag_term($term, $vid);
      }
    }
  }
}

/**
 * Add a tag term 
 */
function _gsb_feature_working_paper_ct_add_tag_term($term, $vid) {
  $new_term = new stdClass();
  $new_term->name = $term;
  $new_term->description = '';
  $new_term->vid = $vid;
  $new_term->parent = null;
  taxonomy_term_save($new_term);
}

/**
 * Get the list of tags from Alfresco
 */
function _gsb_feature_working_paper_ct_getTags($uuid) {

  $tags = array();

  $repo_info = variable_get('cmis_repositories', false);
  if (!$repo_info) {
    return $tags;
  }

  // get the id - striped down to just the number 

  $id = str_replace('urn:uuid:', '', $uuid);

  // put together the url for the alfresco service call - to get 'tags'

  $url = $repo_info['default']['service_url'];
  $url = $url . $id . '/tags';

  // get the user and password

  $user = $repo_info['default']['user'];
  $password = $repo_info['default']['password'];

  // setup the curl options

  $session = curl_init();

  curl_setopt($session, CURLOPT_URL, $url);
  curl_setopt($session, CURLOPT_SSL_VERIFYPEER, FALSE);
  curl_setopt($session, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($session, CURLOPT_FOLLOWLOCATION, 1);
  curl_setopt($session, CURLOPT_COOKIEFILE, "");
  curl_setopt($session, CURLOPT_USERPWD, $user. ":" . $password);
  curl_setopt($session, CURLOPT_HTTPHEADER, array("Content-Type" => ""));
  curl_setopt($session, CURLOPT_CUSTOMREQUEST, "GET");

  // make the return value object

  $retval = new stdClass();
  $retval->url = $url;
  $retval->method = "GET";
  $retval->content_sent = null;
  $retval->content_type_sent = "";

  // make the curl call

  $retval->body = curl_exec($session);

  // set the return values

  $retval->code = curl_getinfo($session, CURLINFO_HTTP_CODE);
  $retval->content_type = curl_getinfo($session, CURLINFO_CONTENT_TYPE);
  $retval->content_length = curl_getinfo($session, CURLINFO_CONTENT_LENGTH_DOWNLOAD);

  // close the curl session

  curl_close($session);

  if ($retval->code == '200') {
    $tags = drupal_json_decode($retval->body);
  }

  return $tags;
}

/**
 * Set the list of tags to Alfresco
 */
function _gsb_feature_working_paper_ct_setTags($uuid, $tags) {

  $repo_info = variable_get('cmis_repositories', false);
  if (!$repo_info) {
    return false;
  }

  // get the id - striped down to just the number 

  $id = str_replace('urn:uuid:', '', $uuid);

  // put together the url for the alfresco service call - to get 'tags'

  $url = $repo_info['default']['service_url'];
  $url = $url . $id . '/tags';

  // get the user and password

  $user = $repo_info['default']['user'];
  $password = $repo_info['default']['password'];

  // setup the curl options

  $session = curl_init();

  curl_setopt($session, CURLOPT_URL, $url);
  curl_setopt($session, CURLOPT_SSL_VERIFYPEER, FALSE);
  curl_setopt($session, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($session, CURLOPT_FOLLOWLOCATION, 1);
  curl_setopt($session, CURLOPT_COOKIEFILE, "");
  curl_setopt($session, CURLOPT_USERPWD, $user. ":" . $password);
  curl_setopt($session, CURLOPT_CUSTOMREQUEST, "POST");

  // pass the tags as data in the header
  $data_string = json_encode($tags);     
                                                                                                                                      
  curl_setopt($session, CURLOPT_POSTFIELDS, $data_string);                                        
  curl_setopt($session, CURLOPT_HTTPHEADER, array(                    
    'Content-Type: application/json',
    'Content-Length: ' . strlen($data_string),
  ));
  
  // make the return value object

  $retval = new stdClass();
  $retval->url = $url;
  $retval->method = "POST";
  $retval->content_sent = null;
  $retval->content_type_sent = "";

  // make the curl call

  $retval->body = curl_exec($session);

  // set the return values

  $retval->code = curl_getinfo($session, CURLINFO_HTTP_CODE);
  $retval->content_type = curl_getinfo($session, CURLINFO_CONTENT_TYPE);
  $retval->content_length = curl_getinfo($session, CURLINFO_CONTENT_LENGTH_DOWNLOAD);

  // close the curl session

  curl_close($session);

  if ($retval->code == '200') {
    $result = drupal_json_decode($retval->body);
  }

  return $result;
  
}

/**
 * Get sunet authors from the Alfresco doc properties
 */
function _gsb_feature_working_paper_ct_import_sunet_authors($node,$ewrapper,$doc) {

  // get the list of sunetids from Alfresco's returned data
  $sunet_ids = array_map('trim', explode(',', $doc->properties['gsb:authorsSunetId']));

  // lookup the node ids related to these ids
  $query = db_select('field_data_field_sunetid', 'su');
  $query->fields('su', array('bundle', 'entity_id', 'field_sunetid_value'));
  $query->condition('su.field_sunetid_value',$sunet_ids,'IN');
  $result = $query->execute();

  // gather a list of entity ids to add and remove
  $add_entity_ids = array();
  $del_field_collection_items = array();

  // start by putting all these node ids in the add list
  foreach ($result as $record) {
    $add_entity_ids[$record->entity_id] = $record->entity_id;
  }

  // get the current list of authors saved with the node
  $authors = $ewrapper->field_authors->value();

  // if any of the author ids match one of the sunetid node ids, then
  // we don't need to add it, and can remove it from our add list.
  // also... 
  // if an author id isn't in the add list, then it needs to be removed
  // so we'll add it to our delete list.
  foreach($authors as $author) {
    $ewrap_author = entity_metadata_wrapper('field_collection_item', $author);
    $ref = $ewrap_author->field_person_fac_single_ref->value();
    if ($ref) {
      $author_nid = $ref->nid;
      if (!empty($add_entity_ids[$author_nid])) {
        unset($add_entity_ids[$author_nid]);
      } else {
        $del_field_collection_items[] = $author;
      }
    }
  }

  // check for an 'default/empty' author field collection
  // remove if this is the case, and we have authors to add
  $found_default = FALSE;
  if (count($authors) == 1) {
    if (empty($authors[0]->field_first_name)) {
      if (empty($authors[0]->field_last_name)) {
        if (empty($authors[0]->field_person_fac_single_ref)) {
          $found_default = TRUE;
        }
      }
    }
  }
  if ($found_default && count($add_entity_ids) > 0) {
    $ewrapper->field_authors->set(NULL);
  }

  // add any new authors that came for the sunetids
  foreach ($add_entity_ids as $entity_id) {
    _gsb_feature_working_paper_ct_add_author($node, $entity_id);
  }  

  // delete any authors that are no longer sunetids in Alfresco
  foreach($del_field_collection_items as $item) {
    $item->delete();
  }

}  

/**
 * Get 'Other Authors' from the Alfresco doc properties
 */
function _gsb_feature_working_paper_ct_import_other_authors($node,$doc) {

  $language = $node->language;

  // get the list of sunetids from Alfresco's returned data
  $sunet_ids = array();
  if (!empty($doc->properties['gsb:authorsSunetId']) && trim($doc->properties['gsb:authorsSunetId']) != '') {
    $sunet_ids = array_map('trim', explode(',', $doc->properties['gsb:authorsSunetId']));
  }

  // get the current list of authors saved with the node
  $ewrapper = entity_metadata_wrapper('node', $node);
  $current_authors = $ewrapper->field_authors->value();

  $other_authors = $doc->properties['cm:author'];
  $other_authors = explode(',', $other_authors);

  // loop thru the list of current authors
  // and remove any that are not in the list
  // of other authors from Alfresco
  foreach($current_authors as $author) {
    $ewrap_author = entity_metadata_wrapper('field_collection_item', $author);
    $fn = $ewrap_author->field_first_name->value();
    $ln = $ewrap_author->field_last_name->value();
    $ref = $ewrap_author->field_person_fac_single_ref->value();
    $author_node = null;
    if ($ref) {
      $authors_nid = $ref->nid;
      $author_node = node_load($authors_nid);
      $fn = $author_node->field_first_name['und'][0]['value'];
      $ln = $author_node->field_last_name['und'][0]['value'];
    }
    $found = false;
    foreach($other_authors as $other_author) {
      $other_author = trim($other_author);
      $other_author = explode(' ',$other_author);
      $first_name = $other_author[0];
      $last_name = $other_author[count($other_author)-1];
      if ($fn == $first_name && $ln == $last_name) {
        $found = true;
        break;
      }
    }
    if (!$found) {
      if ($author_node && !empty($sunet_ids)) {
        // give it one last try to see if the author is in the list of sunetids on Alfresco
        $sunetid = '';
        if (!empty($author_node->field_sunetid[$language][0])) {
          $sunetid = $author_node->field_sunetid[$language][0]['value'];
        }
        if (in_array($sunetid, $sunet_ids)) {
          $found = true;
        }
      }
      if (!$found) {
        $author->delete();
      }
    }
  }

  // loop thru the list of other authors
  // and add any that are not in the list
  // of current authors
  foreach($other_authors as $other_author) {
    $other_author = trim($other_author);
    $other_author = explode(' ',$other_author);
    $first_name = $other_author[0];
    $last_name = $other_author[count($other_author)-1];
    $found = false;
    if (empty($ewrapper->field_authors)) {
      // add any all other authors
    } else {
      foreach($current_authors as $author) {
        $ewrap_author = entity_metadata_wrapper('field_collection_item', $author);
        $fn = $ewrap_author->field_first_name->value();
        $ln = $ewrap_author->field_last_name->value();
        $ref = $ewrap_author->field_person_fac_single_ref->value();
        if ($ref) {
          $authors_nid = $ref->nid;
          $author_node = node_load($authors_nid);
          $fn = $author_node->field_first_name['und'][0]['value'];
          $ln = $author_node->field_last_name['und'][0]['value'];
        }
        if ($fn == $first_name && $ln == $last_name) {
          $found = true;
          break;
        }
      }
    }
    if (!$found) {
      _gsb_feature_working_paper_ct_add_other_author($node, $first_name, $last_name);
    }
  }
}

/**
 * Add an author entity ref (via field_authors field collection) 
 * to the node's current list
 */
function _gsb_feature_working_paper_ct_add_author($node, $entity_id) {

  $language = $node->language;

  $field_collection_item = entity_create('field_collection_item', array('field_name' => 'field_authors'));
  $field_collection_item->setHostEntity('node', $node);

  $field_collection_item->field_person_fac_single_ref = array(
    $language => array(array('target_id' => $entity_id)),
  );

  $field_collection_item->field_person_fac_or_other = array(
    $language => array(array('value' => 'UseEntityReference')),
  );

  $field_collection_item->field_first_name = array();
  $field_collection_item->field_last_name = array();

  $field_collection_item->save();

}

/**
 * Add an author entity 'other' info (via field_authors field collection) 
 * to the first and last name given.
 */
function _gsb_feature_working_paper_ct_add_other_author($node, $first_name, $last_name) {

  // Make a quick check to see if the author being added
  // has faculty node and if so add them using their node ref
  $query = new EntityFieldQuery('node');
  $results = $query
    ->entityCondition('bundle', 'faculty')
    ->fieldCondition('field_first_name', 'value', $first_name)
    ->fieldCondition('field_last_name', 'value', $last_name)
    ->execute();
  if (!empty($results['node'])) {
    $entity_id = key($results['node']);
    _gsb_feature_working_paper_ct_add_author($node, $entity_id);
    return;
  }  

  $field_collection_item = entity_create('field_collection_item', array('field_name' => 'field_authors'));
  $field_collection_item->setHostEntity('node', $node);

  $field_collection_item->field_person_fac_single_ref = array();

  $field_collection_item->field_person_fac_or_other =  array(
    'und' => array(array('value' => 'Other')),
  );

  $field_collection_item->field_first_name = array(
    'und' => array(array('value' => $first_name)),
  );

  $field_collection_item->field_last_name = array(
    'und' => array(array('value' => $last_name)),
  );

  $field_collection_item->field_profile_visibility =  array(
    'und' => array(array('value' => '1')),
  );

  $field_collection_item->save();

}

/**
 * Implements hook_node_presave().
 */
function gsb_feature_working_paper_ct_node_presave($node) {
  // Update Alfresco with node properties
  if ($node->type == 'working_paper' && (empty($node->importing) || !$node->importing)) {
    $repo_info = variable_get('cmis_repositories', false);
    if (!$repo_info) {
      return;
    }    
    $block_update = variable_get('gsb_feature_working_paper_ct_block_update', false);
    if ($block_update) {
      return;
    }        
    if (empty($node->nid) && $node->type == 'working_paper' && empty($node->field_academic_area_unlimited['und'])) {
      _gsb_feature_working_paper_ct_modify_academic_area($node);
    }    
    $result = _gsb_feature_working_paper_ct_updateAlfresco($node);
  }
}

/**
 * Update Alfresco with the new properties for the Working Paper node.
 */
function _gsb_feature_working_paper_ct_updateAlfresco($node) {
  module_load_include('api.inc', 'cmis');

  global $conf;

  $language = $node->language;

  $repository = cmis_get_repository('default');
  $working_paper_folder = variable_get('gsb_feature_working_paper_ct_alfresco_folder', '/Research Papers');

  // get the uuid of the Alfresco Document

  $uuid = -1;
  if (!empty($node->field_document_uuid[$language][0])) {
    $uuid = $node->field_document_uuid[$language][0]['value'];
  }

  // get info about the uploaded file

  $file = null;
  if (!empty($node->field_file_single_public[$language])) {
    $fid = $node->field_file_single_public[$language][0]['fid'];
    $file = file_load($fid);   
  } 
  $folder = cmisapi_getObjectByPath($repository->repositoryId, drupal_encode_path($working_paper_folder) );   

  $filename = '';
  $new_item_id = '';
  if (!empty($node->field_item_id[$language][0])) {
    $filename = 'RP' . (integer)$node->field_item_id[$language][0]['value'];
  } else {
    $new_item_id = (integer)variable_get('gsb_feature_working_paper_ct_item_id');
    $filename = 'RP' . $new_item_id;
    $conf['gsb_feature_working_paper_ct_item_id'] = $new_item_id + 1;
    variable_set('gsb_feature_working_paper_ct_item_id', $conf['gsb_feature_working_paper_ct_item_id']);
  }

  $cmis_object = null;

  // check if we already have a document/uuid on Alfresco

  if ($uuid == -1) {

    // create a document/file on Alfresco
    $cmis_object = _gsb_working_paper_ct_createDocument($repository, $file, $folder, $filename); 

  } else {

    // get existing document/object from Alfresco

    try {
      $cmis_object = gsb_cmis_api_getDocumentObject('default', $uuid);
    } catch (Exception $ex) {
      if (strpos($ex->getMessage(), "CMISObjectNotFoundException")) {      
        // we weren't able to find the document on Alfresco, so we will attempt to re-create it   
        $cmis_object = _gsb_working_paper_ct_createDocument($repository, $file, $folder, $filename);
      }
    }
    
    // stream up file contents, if new file has been uploaded

    if (!empty($file->uri) && $cmis_object != null) {
      $file_content = file_get_contents($file->uri);
      cmisapi_setContentStream(
        $repository->repositoryId,
        $cmis_object->id,
        $file_content, 
        $cmis_object->properties['cmis:contentStreamMimeType']
      );
    
    }

  }

  if ($cmis_object == null) {
    drupal_set_message(t('Error: Creating/Updating document on Alfresco'), 'error', FALSE);
    return false;
  }

  // get the properties for the object from Alfresco

  $properties = cmisapi_getProperties($repository->repositoryId, $cmis_object->id);

  // set the node properties to match the values held by Alfresco

  $node->field_document_uuid[$language][0]['value'] = $properties->uuid;

  // set the item id, if we created a new one 
  
  if (!empty($new_item_id)) {
    $node->field_item_id[$language][0]['value'] = $new_item_id;
  } 

  // set the product type

  $node->field_product_type[$language][0]['value'] = 'Working Paper';

  // set the 'has pdf' checkbox
  
  if ($properties->properties['cmis:contentStreamLength'] > 0) {
    $node->field_has_pdf[$language][0]['value'] = '1';
  } else {
    $node->field_has_pdf[$language][0]['value'] = '0';
  }

  // set the alfresco properties via post to a WebScript

  _gsb_feature_working_paper_ct_setProperties($properties->uuid,$node,$filename);

  // remove file from the Drupal system

  if ($file) {
    $usage = file_usage_list($file);
    if (!empty($usage)) {
      if (count($usage['file']['node']) == 1 && !empty($usage['file']['node'][$node->nid])) {
        file_delete($file,TRUE);
      }
    } else {
      file_delete($file);
    }
  }

  return true;

}

/**
 * Set the properties to Alfresco
 */
function _gsb_feature_working_paper_ct_setProperties($uuid,$node,$filename) {

  $language = $node->language;

  $repo_info = variable_get('cmis_repositories', false);
  if (!$repo_info) {
    return false;
  }

  // get the data properties from the node

  $docname = '';
  if (!empty($filename)) {
    $docname = $filename;
  }

  $title = $node->title;
  $cwoProductType = 'Working Paper';

  $publication_year = '';
  if (!empty($node->field_year_of_publication[$language][0])) {
    $publication_year = $node->field_year_of_publication[$language][0]['value'];
    $publication_year = substr($publication_year, 0, 4);    
  }

  $description = '';
  if (!empty($node->field_description[$language][0])) {
    $description = $node->field_description[$language][0]['value'];  
  }  

  $cwoItemId = '';
  if (!empty($node->field_item_id[$language][0])) {
    $cwoItemId = $node->field_item_id[$language][0]['value'];  
  } 
  
  $cwoAcademicArea = '';
  if (!empty($node->field_academic_area_unlimited[$language][0])) {
    $academic_area_tid = $node->field_academic_area_unlimited[$language][0]['tid'];
    $academic_area_term = taxonomy_term_load($academic_area_tid); 
    $cwoAcademicArea = $academic_area_term->name;
  }

  $cwoBusinessTopics = '';
  if (!empty($node->field_business_insight_topic[$language][0])) {
    $bi_topic_tid = $node->field_business_insight_topic[$language][0]['tid'];
    $bi_topic_term = taxonomy_term_load($bi_topic_tid);
    $cwoBusinessTopics = $bi_topic_term->name;
  }

  $authorSunetIds = array();
  $authors = array();
  if (!empty($node->field_authors[$language][0])) {
    list($authorSunetIds, $authors) = _gsb_feature_working_paper_ct_getAuthorProperties($node);
  }  

  // get the id - striped down to just the number 

  $id = str_replace('urn:uuid:', '', $uuid);

  // put together the url for the alfresco service call - to get 'tags'

  $url = $repo_info['default']['service_url'];
  $url = str_replace('api/node/workspace/SpacesStore/','gsb/updateworkingpaper',$url);

  // get the user and password

  $user = $repo_info['default']['user'];
  $password = $repo_info['default']['password'];

  // setup the curl options

  $session = curl_init();

  curl_setopt($session, CURLOPT_URL, $url);
  curl_setopt($session, CURLOPT_SSL_VERIFYPEER, FALSE);
  curl_setopt($session, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($session, CURLOPT_FOLLOWLOCATION, 1);
  curl_setopt($session, CURLOPT_COOKIEFILE, "");
  curl_setopt($session, CURLOPT_USERPWD, $user. ":" . $password);
  curl_setopt($session, CURLOPT_CUSTOMREQUEST, "POST");

  // pass the properties as data in the header

  $data = array(
    'uuid' => $id,    
    'docname' => $docname,
    'title' => $title,
    'description' => $description,    
    'cwoPublicationYear' => $publication_year,
    'cwoAcademicArea' => $cwoAcademicArea,
    'cwoBusinessTopics' => $cwoBusinessTopics,
    'cwoItemId' => $cwoItemId,
    'cwoProductType' => $cwoProductType,
    'authorsSunetId' => implode(', ', $authorSunetIds),
    'author' => implode(', ', $authors), 
  );

  // encode the data

  $encoded = '';
  foreach($data as $name => $value){
    $encoded .= urlencode($name).'='.urlencode($value).'&';
  }

  // chop off the last ampersand
  
  $encoded = substr($encoded, 0, strlen($encoded)-1);
  
  // set the postfields

  curl_setopt($session, CURLOPT_POSTFIELDS,  $encoded);

  // set the http header

  curl_setopt($session, CURLOPT_HTTPHEADER, array(                    
    'Content-Length: ' . strlen($encoded),
  ));
  
  // make the return value object

  $retval = new stdClass();
  $retval->url = $url;
  $retval->method = "POST";
  $retval->content_sent = null;
  $retval->content_type_sent = "";

  // make the curl call

  $retval->body = curl_exec($session);

  // set the return values

  $retval->code = curl_getinfo($session, CURLINFO_HTTP_CODE);
  $retval->content_type = curl_getinfo($session, CURLINFO_CONTENT_TYPE);
  $retval->content_length = curl_getinfo($session, CURLINFO_CONTENT_LENGTH_DOWNLOAD);

  // close the curl session

  curl_close($session);

  $result = '';
  if ($retval->code == '200') {
    $result = drupal_json_decode($retval->body);
  }

  return $result;
  
}

/**
 * Get the Author properties 
 */
function _gsb_feature_working_paper_ct_getAuthorProperties($node) {

  $language = $node->language;

  $authorSunetIds = array();
  $authors = array();

  if (empty($node->field_authors[$language][0])) {
    return array($authorSunetIds, $authors);
  }  

  foreach($node->field_authors[$language] as $author_item) {

    $authors_nid = $author_item['value'];

    $ewrap_author = entity_metadata_wrapper('field_collection_item', $authors_nid);
    $ref = $ewrap_author->field_person_fac_single_ref->value();

    if ($ref) {
      $authors_nid = $ref->nid;
      $author_node = node_load($authors_nid);
      $authorSunetIds[] = $author_node->field_sunetid[$language][0]['value'];  
      $first_name = $author_node->field_first_name['und'][0]['value'];
      $last_name = $author_node->field_last_name['und'][0]['value'];
      $authors[] = $first_name . ' ' . $last_name;      
    } else {
      $first_name = $ewrap_author->field_first_name->value();
      $last_name = $ewrap_author->field_last_name->value();
      $authors[] = $first_name . ' ' . $last_name;
    } 

  }

  return array($authorSunetIds, $authors);

}

/**
 * Add the docname as a prefix for the file upload field
 */
function _gsb_feature_working_paper_ct_addDocName(&$form) {
  module_load_include('api.inc', 'cmis');

  $language = $form['language']['#value'];
  $uuid = -1;
  $docname = '';

  if (!empty($form['nid'])) {    
    if (empty($form['nid']['#value'])) {
      $form['field_file_single_public'][$language][0]['#title'] = 'Add Document';
      return;
    }
    $nid = $form['nid']['#value'];
    $node = node_load($nid);
    if (!empty($node->field_document_uuid[$language][0])) {
      $uuid = $node->field_document_uuid[$language][0]['value'];
    }
    if ($uuid != -1) {      
      try {
        $object = gsb_cmis_api_getDocumentObject('default', $uuid);
        $docname = $object->properties['cmis:contentStreamFileName'];
        if ($docname && $object->properties['cmis:contentStreamLength'] > 0) {
          $form['field_file_single_public']['#prefix'] = '<a class="gsb-cmis-current-doc" href="/gsb-cmis/gsb-cmis-download-doc/'.$nid.'" target="_blank">Current document</a>';
          $form['field_file_single_public'][$language][0]['#title'] = 'Update Document';
        }
      } catch (Exception $ex) {
        // if we can't find the document then assume it needs to be added
        if (strpos($ex->getMessage(), "CMISObjectNotFoundException")) {
          $form['field_file_single_public'][$language][0]['#title'] = 'Add Document';
        }
      }
    }
  }
}

/**
 * Create a document on Alfresco
 */
function _gsb_working_paper_ct_createDocument($repository, $file, $folder, $filename) {
  
  $cmis_object = null;
  
  if (empty($file->uri)) {
    try {
      $cmis_object = cmisapi_createDocument(
        $repository->repositoryId,
        $folder->id,
        $filename
      );      
    } catch (Exception $ex) {
      if (strpos($ex->getMessage(), "FileExistsException")) {
        drupal_set_message(t('Error: Unable to create document on Alfresco - file already exists '.$filename), 'error', FALSE);
      } else {
        drupal_set_message(t('Error: Unable to create document on Alfresco'), 'error', FALSE);
      }
    }   
    return $cmis_object;
  }

  try {
    $cmis_object = cmisapi_createDocument(
      $repository->repositoryId,
      $folder->id,
      $filename,
      array(),
      @file_get_contents($file->uri),
      $file->filemime
    );      
  } catch (Exception $ex) {
    if (strpos($ex->getMessage(), "FileExistsException")) {
      drupal_set_message(t('Error: Unable to create document on Alfresco - file already exists '.$filename), 'error', FALSE);
    } else {
      drupal_set_message(t('Error: Unable to create document on Alfresco'), 'error', FALSE);
    }
  }   
  return $cmis_object;
}

/**
 * Get the cmis object for a given path and filename. 
 * If path is empty, assumes default path to our Working Papers.
 */
function _gsb_working_paper_ct_getObjectByPath($path, $filename) {
  module_load_include('api.inc', 'cmis');

  $working_paper_folder = variable_get('gsb_feature_working_paper_ct_alfresco_folder', '/Research Papers');

  $repository = cmis_get_repository('default');

  if (empty($path)) {
    $path = $working_paper_folder . $filename;  
  } else {
    $path = $path . $filename;        
  }
  
  try {  
    $object = cmisapi_getObjectByPath($repository->repositoryId, drupal_encode_path($path));
  } catch (Exception $ex) {
    return null;
  }  
 
  return $object;  
}

/**
 * Get a unique name so we can add the doc into Alfresco.
 * Note: We will only make 10 attempts to come up with a unique name. 
 * If no unique name is found, we will give back an empty string.
 */
function _gsb_working_paper_ct_getUniqueName($path, $filename) {
  $parts = explode('.', $filename);
  $new_filename = $filename;
  $found = false;
  for($index = 1; $index < 10; $index++) {
    $new_filename = $parts[0].' copy'.$index.'.'.$parts[1];
    $object = _gsb_working_paper_ct_getObjectByPath($path, '/'.$new_filename);
    if ($object == null) {
      $found = true;
      break;
    }
  }
  if (!$found) {
    return '';
  }
  return $new_filename;
}

/**
 * Sets a default academic area if none has been set on the new node.
 */
function _gsb_feature_working_paper_ct_modify_academic_area(&$node) {

  // check if academic area is set
  // if academic area is not set we will try to use the author's academic area

  // get the entity wrapper for the node
  $ewrap_working_paper = entity_metadata_wrapper('node', $node);

  // get the authors info
  $authors = $ewrap_working_paper->field_authors->value();

  // get the first author and update the node

  $academic_area_tids = array();

  if (!empty($authors)) {
    foreach ($authors as $author) {
      if (!empty($author->field_person_fac_single_ref['und']) && !empty($author->field_person_fac_single_ref['und'][0]['target_id'])) {

        // get author's node id
        $author_nid = $author->field_person_fac_single_ref['und'][0]['target_id'];

        // load the author node
        $author_node = node_load($author_nid);

        // update the node with this author

        // get entity wrapper for the author node
        $ewrap_author = entity_metadata_wrapper('node', $author_node);

        // get the term for the author's academic area
        $academic_area = $ewrap_author->field_academic_area_single->value();

        if ($academic_area != null) {
          $tid = $academic_area->tid;
          $academic_area_tids[$tid] = $tid;
        }

      }
    }

    foreach($academic_area_tids as $tid) {
      $node->field_academic_area_unlimited['und'][] = array('tid' => $tid);
    }    

  }

}
